{$DEFINE SCRIPT_REVISION := '80085'}
{$IFDEF WINDOWS}{$DEFINE SCRIPT_GUI}{$ENDIF}
{$I SRL-T/osr.simba}
{$I WaspLib/osr.simba}
{$I WaspLib/optional/handlers/discord.simba}

var
  WEBHOOKURL: String                     = '';
  ENABLEWEBHOOKS: Boolean                = True; 
  ENABLEWORLDHOPPING: Boolean            = True;
  WORLDHOPINTERVAL: Integer              = 45;
  SENDLEVELUPNOTIFICATIONMSG: Boolean    = True;
  SENDSESSIONSUMMARYMSG: Boolean         = True;
  SENDHOURLYREPORTMSG: Boolean           = True;
  ABLOSEFOCUS: Boolean                   = True;

type
  GemStoneCrabSlayer = record(TBaseBankScript)
    InCombat: Boolean;
    IsAttacking: Boolean;
    LastHealthCheck: UInt64;
    
    TotalKills: Int32;
    StartXP: Int32;
    CurrentXP: Integer;
    PrevXP: Integer;
    XPGained: Integer;
    LastLevel: Int32;
    CurrentLevel: Int32;
    LastHourlyReportTime: Int64;
    GainedXP: Integer;
    
    CaveEntranceAttempts: Int32;
    LastCaveAttemptTime: UInt64;
    LastCaveEntryTime: UInt64;
    FailsafeActive: Boolean;
    
    ConsecutiveFailedAttacks: Int32;
    LastFailedAttackTime: UInt64;
    LastSuccessfulClick: Boolean;
    
    RunningTime: TStopWatch;
    ActiveTimer: TStopWatch;
    
    LastAPIUpdate: UInt64;
    ApiUpdateInterval: UInt64;
    
    NextWorldHopTime: UInt64;
    WorldHopsCompleted: Int32;
    LastWorldHopTime: Int64;
    
    LastReportTime: UInt64;
    LastImageClear: UInt64;
    LastSystemUpdateCheck: UInt64;
    SystemUpdateWarningShown: Boolean;
  end;

var
  GemStoneCrabBot: GemStoneCrabSlayer;
  Discord: TDiscordClient;
  ActiveTimer: TStopWatch;
  
  NPC_DTM1, NPC_DTM2, NPC_DTM3, NPC_DTM4, NPC_DTM5, NPC_DTM6, NPC_DTM7: Int64;

procedure SetupNPCDTMs();
begin
  NPC_DTM1 := DTMFromString('mQwAAAHicY2ZgYGhnguAOIA4G8kOBOASI374FEgyMUIwAjKiiANXeBHs=');
  NPC_DTM2 := DTMFromString('mQwAAAHicY2ZgYKhnguA6IA4A8gMZIPTdu0CCgRGKEYARVRQAyRcENg==');
  NPC_DTM3 := DTMFromString('mQwAAAHicY2ZgYGhgguBGIPYD8n0ZIPTXrwwM//7xMdy9y4ACGJEwEAAASrQIJQ==');
  NPC_DTM4 := DTMFromString('mQwAAAHicY2ZgYKhnguA6IPYD8n0ZIPSfP0wM//4JgzEyYETCQAAAVqMIig==');
  NPC_DTM5 := DTMFromString('mQwAAAHicY2ZgYGhgYmBohOIQID8MiIOA+M8foAADI8O/f8IMyIARCQMBABS6BpU=');
  NPC_DTM6 := DTMFromString('mQwAAAHicY2ZgYGhhguBWIA4B8sOg+M8foAADIxQjACOqKADZUASW');
  NPC_DTM7 := DTMFromString('mQwAAAHicY2ZgYGhhguBmIA4G8kOBOAiI794FEgyMDP/+8TEgA0YkDAQADEUGVw==');
end;

procedure FreeNPCDTMs();
begin
  FreeDTM(NPC_DTM1);
  FreeDTM(NPC_DTM2);
  FreeDTM(NPC_DTM3);
  FreeDTM(NPC_DTM4);
  FreeDTM(NPC_DTM5);
  FreeDTM(NPC_DTM6);
  FreeDTM(NPC_DTM7);
end;

function FilterDuplicateDots(Dots: TPointArray): TPointArray;
var
  I, J: Integer;
  TooClose: Boolean;
  MinDistance: Integer = 7;
begin
  Result := [];
  
  for I := 0 to High(Dots) do
  begin
    TooClose := False;
    
    for J := 0 to High(Result) do
    begin
      if Dots[I].DistanceTo(Result[J]) < MinDistance then
      begin
        TooClose := True;
        Break;
      end;
    end;
    
    if not TooClose then
    begin
      SetLength(Result, Length(Result) + 1);
      Result[High(Result)] := Dots[I];
    end;
  end;
end;

function GemStoneCrabSlayer.GetRandomWorldHopTime(): UInt64;
var
  BaseInterval: UInt64;
  RandomVariation: Integer;
begin
  BaseInterval := WORLDHOPINTERVAL * 60000;
  
  // ±25% random variation to the interval eitherside
  RandomVariation := Random(-25, 25);
  Result := BaseInterval + Round(BaseInterval * (RandomVariation / 100.0));
  
  if Result < 900000 then
    Result := 900000;
    
  WriteLn('Next world hop scheduled in: ' + SRL.MsToTime(Result, Time_Short) + 
          ' (Base: ' + IntToStr(WORLDHOPINTERVAL) + 'min, Variation: ' + IntToStr(RandomVariation) + '%)');
end;

function GemStoneCrabSlayer.GetWorldHopTimeRange(): String;
var
  MinInterval, MaxInterval: Integer;
begin
  MinInterval := Round(WORLDHOPINTERVAL * 0.75);
  MaxInterval := Round(WORLDHOPINTERVAL * 1.25);
  
  if MinInterval < 15 then
    MinInterval := 15;
    
  Result := IntToStr(MinInterval) + '-' + IntToStr(MaxInterval) + ' min';
end;

procedure GemStoneCrabSlayer.SetupWorldHopping();
begin
  WriteLn('Setting up world hopping...');
  
  if not ENABLEWORLDHOPPING then
  begin
    WriteLn('World hopping is disabled.');
    Exit;
  end;

  if Length(Login.GetPlayer().Worlds) < 2 then
  begin
    WriteLn('ERROR: World hopping is enabled but you have less than 2 worlds configured!');
    WriteLn('Please configure at least 2 worlds in your player setup or disable world hopping.');
    Logout.ClickLogout();
    TerminateScript();
  end;

  Self.NextWorldHopTime := GetTickCount() + Self.GetRandomWorldHopTime();
  WriteLn('World hopping enabled. Next hop in: ' + SRL.MsToTime(Self.NextWorldHopTime - GetTickCount(), Time_Short));
end;

function GemStoneCrabSlayer.ShouldHopWorld(): Boolean;
var
  TimeSinceLastCombat: UInt64;
  RequiredCombatCooldown: UInt64;
begin
  if not ENABLEWORLDHOPPING then
    Exit(False);
    
  // Don't trynhop if we're currently in combat
  if Self.InCombat or Self.IsAttacking then
    Exit(False);
  
  TimeSinceLastCombat := GetTickCount() - Self.LastHealthCheck;
  
  // Require 15-30 seconds out of combat before allowing world hop for combat drop
  RequiredCombatCooldown := Random(15000, 30000); // 15-30 seconds
  
  if TimeSinceLastCombat < RequiredCombatCooldown then
  begin
    Exit(False);
  end;
    
  Result := GetTickCount() >= Self.NextWorldHopTime;
end;

procedure GemStoneCrabSlayer.DoWorldHop();
var
  currentWorld: Int32;
  playerWorlds: TIntegerArray;
  targetWorld: Int32;
  availableWorlds: TIntegerArray;
  i: Int32;
begin
  if not ENABLEWORLDHOPPING then
    Exit;

  if Self.InCombat or Self.IsAttacking then
  begin
    WriteLn('Skipping world hop - currently in combat');
    Self.NextWorldHopTime := GetTickCount() + 120000;
    Exit;
  end;

  WriteLn('Time to hop worlds!');
  
  playerWorlds := Login.GetPlayer().Worlds;
  
  if not Logout.Open() then
  begin
    WriteLn('Failed to open logout menu');
    Self.NextWorldHopTime := GetTickCount() + 120000;
    Exit;
  end;

  if not Logout.IsWorldSwitcherOpen() then
    Logout.GetButton(ERSLogoutButton.WORLD_SWITCHER).Click(MOUSE_LEFT);
  WaitUntil((currentWorld := WorldHopper.GetCurrentWorld()) <> 0, 200, 12000);
  
  WriteLn('Current world: ' + ToStr(currentWorld));
  WriteLn('Available worlds: ' + ToStr(playerWorlds));

  availableWorlds := [];
  for i := 0 to High(playerWorlds) do
  begin
    if playerWorlds[i] <> currentWorld then
      availableWorlds += playerWorlds[i];
  end;
  
  if Length(availableWorlds) = 0 then
  begin
    WriteLn('No other worlds available to hop to, disabling world hopping!');
    ENABLEWORLDHOPPING := False;
    Exit;
  end;
  
  targetWorld := availableWorlds[Random(Length(availableWorlds))];
  WriteLn('Randomly selected target world: ' + ToStr(targetWorld));

  if WorldHopper.Hop([targetWorld]) then
  begin
    WriteLn('Successfully hopped to world ' + ToStr(targetWorld) + '!');
    
    Inc(Self.WorldHopsCompleted);
    Self.LastWorldHopTime := GetTickCount();

    Self.NextWorldHopTime := GetTickCount() + Self.GetRandomWorldHopTime();
    WriteLn('Next world hop in: ' + SRL.MsToTime(Self.NextWorldHopTime - GetTickCount(), Time_Short));
  end
  else
  begin
    WriteLn('World hop to ' + ToStr(targetWorld) + ' failed, trying again in 2 minutes');
    Self.NextWorldHopTime := GetTickCount() + 120000;
  end;
end;

function FindYellowNPCDots(): TPointArray;
var
  TempPoints: TPointArray;
begin
  Result := [];
  
  if FindDTMs(NPC_DTM1, TempPoints, Minimap.Bounds) then
    Result := Result + TempPoints;
  
  if FindDTMs(NPC_DTM2, TempPoints, Minimap.Bounds) then
    Result := Result + TempPoints;
  
  if FindDTMs(NPC_DTM3, TempPoints, Minimap.Bounds) then
    Result := Result + TempPoints;
  
  if FindDTMs(NPC_DTM4, TempPoints, Minimap.Bounds) then
    Result := Result + TempPoints;
  
  if FindDTMs(NPC_DTM5, TempPoints, Minimap.Bounds) then
    Result := Result + TempPoints;
  
  if FindDTMs(NPC_DTM6, TempPoints, Minimap.Bounds) then
    Result := Result + TempPoints;
  
  if FindDTMs(NPC_DTM7, TempPoints, Minimap.Bounds) then
    Result := Result + TempPoints;
  
  Result := FilterDuplicateDots(Result);
end;

// Thanks Bootie
function TRSChat.CheckSystemUpdate(minuteTreshold: Integer): Boolean;
var
  b: TBox;
  s: String;
  numbers: TExtendedArray;
begin
  b := Chat.Bounds;
  b.X1 += 4;
  b.Y1 -= 16;
  b.Y2 := Chat.Bounds.Y1 -1;
  b.X2 := b.X1 + 140;

  s := OCR.Recognize(
      b,
      TOCRColorFilter.Create([65535]),
      RS_FONT_PLAIN_12
    );

  if s.Contains('System update') then
  begin
    s := s.After(': ');
    numbers := s.ExtractNumbers();
    if (length(numbers) > 0) and (numbers[0] <= minuteTreshold) then
      Result := True;
  end;
end; 

procedure OnBreakStart(Task: PBreakTask);
begin
  ActiveTimer.Pause();
end;

procedure OnBreakFinish(Task: PBreakTask);
begin
  ActiveTimer.Resume();
end;

procedure OnSleepStart(Task: PSleepTask);
begin
  ActiveTimer.Pause();
end;

procedure OnSleepFinish(Task: PSleepTask);
begin
  ActiveTimer.Resume();
end;

procedure TAntiban.Setup(); override;
begin
  Self.Skills := [ERSSkill.TOTAL, ERSSkill.ATTACK, ERSSkill.STRENGTH, ERSSkill.DEFENCE, ERSSkill.HITPOINTS];
  Self.MinZoom := 0;
  Self.MaxZoom := 10;
  
  // Disable random tab switching for chatbot and like who does this
  WLSettings.SetAntibanGametabs(False);
  
  Antiban.OnStartBreak := @OnBreakStart;
  Antiban.OnFinishBreak := @OnBreakFinish;
  Antiban.OnStartSleep := @OnSleepStart;
  Antiban.OnFinishSleep := @OnSleepFinish;

  inherited;
end;

procedure TRSObject.SetObject(objUpText: TStringArray; coordinates: TPointArray; size, height: double);
begin
  Self := [];
  Self.Setup(size, height, coordinates);
  Self.Setup(objUpText);

  Filter := [True, False, True, True];
end;

{$IFDEF SCRIPT_GUI}
type
  TConfig = record(TScriptForm)
    WebhookLabel: TLabel;
    WebHookInput: TLabeledEdit;
    WorldHopIntervalInput: TLabeledEdit;
    EnableWebhooksCheckBox,
    HourlyReportsCheckBox, ScreenshotOnLevelCheckBox, SessionSummaryCheckBox, 
    LoseFocusCheckBox, EnableWorldHoppingCheckBox: TLabeledCheckBox;
    WebhookInfo: TLabel;
    TestButton: TButton;
    SavedWebhookURL: String;
    DiscordPanel: TLabeledPanel;
    Username: String;
  end;

procedure TConfig.UpdateAccountValues(sender: TObject);
var
  selector: TComboBox;
  user, pass, pin: TEdit;
  worlds: TMemo;
  idx: Int32;
  worldsStr: String;
  i: Int32;
begin
  selector := TComboBox(Self.Form.GetChild('am_selector_combobox'));
  idx := selector.GetItemIndex();

  if (idx < 0) or (idx > High(Login.Players)) then Exit;
  
  Self.SaveUserSettings();

  Login.PlayerIndex := idx;

  user := TEdit(Self.Form.GetChild('am_user_edit'));
  pass := TEdit(Self.Form.GetChild('am_pass_edit'));
  pin := TEdit(Self.Form.GetChild('am_pin_edit'));
  worlds := TMemo(Self.Form.GetChild('am_worlds_memo'));

  user.SetText(Login.Players[idx].User);
  pass.SetText(Login.Players[idx].Password);
  pin.SetText(Login.Players[idx].Pin);

  worldsStr := '';
  for i := 0 to High(Login.Players[idx].Worlds) do
  begin
    worldsStr += ToStr(Login.Players[idx].Worlds[i]);
    if i < High(Login.Players[idx].Worlds) then
      worldsStr += ', ';
  end;
  worlds.SetText(worldsStr);

  Self.LoadUserSettings();
end;

procedure TConfig.InitializeAccountManager;
var
  selector: TComboBox;
begin
  selector := TComboBox(Self.Form.GetChild('am_selector_combobox'));
  selector.SetOnChange(@UpdateAccountValues);
end;
  
procedure TConfig.LoadUserSettings();
var
  SavedWebhookURL: String;
  SavedEnableWebhooks: Boolean;
  SavedHourlyReports, SavedLevelUpNotifications, SavedSessionSummary, SavedLoseFocus, SavedEnableWorldHopping: Boolean;
  SavedWorldHopInterval: Integer;
  Username: String;
begin
 if (Login.PlayerIndex < 0) or (Login.PlayerIndex > High(Login.Players)) then
    Username := 'NoUserNameSelected'
  else
    Username := Login.Players[Login.PlayerIndex].User;

  if Username = '' then Exit;

  SavedHourlyReports := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'HourlyReports', 'Configs/BASettings.ini'), True);
  SavedLevelUpNotifications := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'ScreenshotOnLevel', 'Configs/BASettings.ini'), True);
  SavedSessionSummary := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'SessionSummary', 'Configs/BASettings.ini'), True);
  SavedLoseFocus := StrToBoolDef(ReadINI(Username + ' Antiban Manager', 'LoseFocus', 'Configs/BASettings.ini'), True);
  SavedWebhookURL := ReadINI(Username + ' Webhook Settings', 'WebhookURL', 'Configs/BASettings.ini');
  SavedEnableWebhooks := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'EnableWebhooks', 'Configs/BASettings.ini'), False);
  SavedEnableWorldHopping := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'EnableWorldHopping', 'Configs/BASettings.ini'), False);
  SavedWorldHopInterval := StrToIntDef(ReadINI(Username + ' Gemstone Crab Settings', 'WorldHopInterval', 'Configs/BASettings.ini'), 45);

  if Assigned(Self.HourlyReportsCheckBox) then
    Self.HourlyReportsCheckBox.SetChecked(SavedHourlyReports);

  if Assigned(Self.ScreenshotOnLevelCheckBox) then
    Self.ScreenshotOnLevelCheckBox.SetChecked(SavedLevelUpNotifications);

  if Assigned(Self.SessionSummaryCheckBox) then
    Self.SessionSummaryCheckBox.SetChecked(SavedSessionSummary);

  if Assigned(Self.LoseFocusCheckBox) then
    Self.LoseFocusCheckBox.SetChecked(SavedLoseFocus);

  if Assigned(Self.EnableWebhooksCheckBox) then
  begin
    Self.EnableWebhooksCheckBox.SetChecked(SavedEnableWebhooks);
    Self.WebhooksCheckboxChanged(Self.EnableWebhooksCheckBox.CheckBox);
  end;

  if Assigned(Self.EnableWorldHoppingCheckBox) then
    Self.EnableWorldHoppingCheckBox.SetChecked(SavedEnableWorldHopping);

  if Assigned(Self.WorldHopIntervalInput) then
    Self.WorldHopIntervalInput.SetText(IntToStr(SavedWorldHopInterval));

  if Assigned(Self.WebHookInput) then
    Self.WebHookInput.SetText(SavedWebhookURL);
end;

procedure TConfig.SaveUserSettings();
var
  Username: String;
begin
 if (Login.PlayerIndex < 0) or (Login.PlayerIndex > High(Login.Players)) then
    Username := 'NoUserNameSelected'
  else
    Username := Login.Players[Login.PlayerIndex].User;
    
  if Username = '' then Exit;

  if Assigned(Self.HourlyReportsCheckBox) then
    SENDHOURLYREPORTMSG := Self.HourlyReportsCheckBox.IsChecked();

  if Assigned(Self.ScreenshotOnLevelCheckBox) then
    SENDLEVELUPNOTIFICATIONMSG := Self.ScreenshotOnLevelCheckBox.IsChecked();

  if Assigned(Self.SessionSummaryCheckBox) then
    SENDSESSIONSUMMARYMSG := Self.SessionSummaryCheckBox.IsChecked();

  if Assigned(Self.LoseFocusCheckBox) then
    ABLOSEFOCUS := Self.LoseFocusCheckBox.IsChecked();

  if Assigned(Self.EnableWebhooksCheckBox) then
    ENABLEWEBHOOKS := Self.EnableWebhooksCheckBox.IsChecked();

  if Assigned(Self.EnableWorldHoppingCheckBox) then
    ENABLEWORLDHOPPING := Self.EnableWorldHoppingCheckBox.IsChecked();

  if Assigned(Self.WorldHopIntervalInput) then
    WORLDHOPINTERVAL := StrToIntDef(Self.WorldHopIntervalInput.GetText(), 45);

  if Assigned(Self.WebHookInput) then
    WEBHOOKURL := Self.WebHookInput.GetText();

  WriteINI(Username + ' Webhook Settings', 'WebhookURL', WEBHOOKURL, 'Configs/BASettings.ini');
  WriteINI(Username + ' Webhook Settings', 'EnableWebhooks', BoolToStr(ENABLEWEBHOOKS, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Webhook Settings', 'HourlyReports', BoolToStr(SENDHOURLYREPORTMSG, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Webhook Settings', 'ScreenshotOnLevel', BoolToStr(SENDLEVELUPNOTIFICATIONMSG, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Webhook Settings', 'SessionSummary', BoolToStr(SENDSESSIONSUMMARYMSG, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Antiban Manager', 'LoseFocus', BoolToStr(ABLOSEFOCUS, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'EnableWorldHopping', BoolToStr(ENABLEWORLDHOPPING, 'true', 'false'), 'Configs/BASettings.ini');
  WriteINI(Username + ' Gemstone Crab Settings', 'WorldHopInterval', IntToStr(WORLDHOPINTERVAL), 'Configs/BASettings.ini');
end;

procedure TConfig.StartScript(sender: TObject); override; 
begin
  Self.SaveUserSettings();
   Discord.SetWebhook(WEBHOOKURL);
   Discord.SetUsername('BigAussies Gemstone Crab Slayer'); 
   Discord.SetAvatar('https://oldschool.runescape.wiki/images/thumb/2/2e/Gemstone_crab.png/150px-Gemstone_crab.png');
  inherited;
end;

procedure TConfig.OpenURL(Sender: TObject);
begin
  if Sender = Self.WebhookInfo then
    OpenWebPage('https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks');
end;

procedure TConfig.WebhooksCheckboxChanged({$H-}sender: TObject){$H+};
begin
  Self.WebhookInfo.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
  if Assigned(Self.DiscordPanel) then
    Self.DiscordPanel.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
  if Assigned(Self.WebHookInput) then
    Self.WebHookInput.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
  if Assigned(Self.TestButton) then
    Self.TestButton.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
  if Assigned(Self.ScreenshotOnLevelCheckBox) then
    Self.ScreenshotOnLevelCheckBox.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
  if Assigned(Self.HourlyReportsCheckBox) then
    Self.HourlyReportsCheckBox.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
  if Assigned(Self.SessionSummaryCheckBox) then
    Self.SessionSummaryCheckBox.SetVisible(Self.EnableWebhooksCheckBox.IsChecked());
end;

procedure TConfig.WorldHoppingCheckboxChanged({$H-}sender: TObject){$H+};
begin
  if Assigned(Self.WorldHopIntervalInput) then
    Self.WorldHopIntervalInput.SetVisible(Self.EnableWorldHoppingCheckBox.IsChecked());
end;

function TConfig.CreateLabeledPanel(owner: TControl; title: String; top, height: Int32; FontSize: Int32 = 10; Color: TColor = clBlack; FontStyles: TFontStyles = [fsBold]): TLabeledPanel;
var
  verticalSpacing: Int32;
begin
  verticalSpacing := TControl.AdjustToDPI(3);
  Result.Create(owner);
  with Result do
  begin
    SetCaption(title);

    Panel.SetCaption('');
    Panel.SetBevelWidth(1);
    Panel.SetBevelInner(bvRaised);
    Panel.SetBevelOuter(bvLowered);
    Panel.SetTop(top + verticalSpacing);
    Panel.SetWidth(Self.Form.GetWidth - TControl.AdjustToDPI(25));
    Panel.SetHeight(TControl.AdjustToDPI(height));
    Panel.SetBorderStyle(bsNone);

    Caption.SetFontSize(FontSize);
    Caption.SetFontColor(Color);
    Caption.GetFont().SetStyle(FontStyles);
  end;
end;

procedure TConfig.TestButtonClick({$H-}sender: TObject){$H+};
begin
  if Self.WebHookInput.GetText = '' then
  begin
    ShowMessage('Please enter a Webhook URL');
    Exit;
  end;
  Discord.Webhook.Content := ('Test message from BigAussies Gemstone Crab Slayer');
  Discord.Webhook.URL := Self.WebHookInput.GetText;
  Discord.Send();
  ShowMessage('Test message sent. Please check Discord.');
end;

procedure TConfig.Run(); override;
var
  tab: TTabSheet;
  SavedWebhookURL: String;
  SavedEnableWebhooks: Boolean;
  SavedScreenshotOnLevel, SavedHourlyReports, SavedSessionSummary, SavedLoseFocus, SavedEnableWorldHopping: Boolean;
  SavedWorldHopInterval: Integer;
  panelTop: Int32;
begin
  //ClearDebug();
  
  if (Login.PlayerIndex < 0) or (Login.PlayerIndex > High(Login.Players)) then
    Username := 'NoUserNameSelected'
  else
    Username := Login.Players[Login.PlayerIndex].User;

  Self.Setup('BigAussies Gemstone Crab Slayer');
  Self.Start.SetOnClick(@Self.StartScript);

  WLSettings.RemoteInput.BlockInput := True;

  Self.AddTab('Script Settings');
  tab := Self.Tabs[High(Self.Tabs)];

  Self.CreateAccountManager(tab);
  InitializeAccountManager();
  Self.LoadUserSettings();

  SavedWebhookURL := ReadINI(Username + ' Webhook Settings', 'WebhookURL', 'Configs/BASettings.ini');
  SavedEnableWebhooks := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'EnableWebhooks', 'Configs/BASettings.ini'), False);
  SavedScreenshotOnLevel := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'ScreenshotOnLevel', 'Configs/BASettings.ini'), True);
  SavedHourlyReports := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'HourlyReports', 'Configs/BASettings.ini'), True);
  SavedSessionSummary := StrToBoolDef(ReadINI(Username + ' Webhook Settings', 'SessionSummary', 'Configs/BASettings.ini'), True);
  SavedLoseFocus := StrToBoolDef(ReadINI(Username + ' Antiban Manager', 'LoseFocus', 'Configs/BASettings.ini'), True);
  SavedEnableWorldHopping := StrToBoolDef(ReadINI(Username + ' Gemstone Crab Settings', 'EnableWorldHopping', 'Configs/BASettings.ini'), False);
  SavedWorldHopInterval := StrToIntDef(ReadINI(Username + ' Gemstone Crab Settings', 'WorldHopInterval', 'Configs/BASettings.ini'), 45);

  with Self.EnableWorldHoppingCheckBox do
  begin
    Create(tab);
    SetCaption('Enable World Hopping');
    SetLeft(TControl.AdjustToDPI(37));
    SetTop(TControl.AdjustToDPI(140));
    SetHint('Hop worlds at random intervals. Requires at least 2 worlds in player setup.');
    SetChecked(SavedEnableWorldHopping);
    CheckBox.SetOnChange(@WorldHoppingCheckboxChanged);
  end;

  with Self.WorldHopIntervalInput do
  begin
    Create(tab);
    SetCaption('World Hop Interval (minutes)');
    SetLeft(Self.EnableWorldHoppingCheckBox.GetRight() + TControl.AdjustToDPI(20));
    SetTop(Self.EnableWorldHoppingCheckBox.GetTop() - TControl.AdjustToDPI(5));
    SetWidth(TControl.AdjustToDPI(160));
    SetText(IntToStr(SavedWorldHopInterval));
    SetHint('Base interval in minutes between world hops (±25% random variation)');
    Edit.SetOnKeyPress(@Edit.NumberField);
  end;

  with Self.EnableWebhooksCheckBox do
  begin
    Create(tab);
    SetCaption("Discord Notifications");
    SetLeft(TControl.AdjustToDPI(37));
    SetTop(Self.EnableWorldHoppingCheckBox.GetTop() + TControl.AdjustToDPI(25));
    SetHint('Enable Discord notifications for crashes and updates.');
    SetChecked(SavedEnableWebhooks);
    CheckBox.SetOnChange(@WebhooksCheckboxChanged);
  end;

  panelTop := Self.EnableWebhooksCheckBox.GetTop() + TControl.AdjustToDPI(30);
  Self.DiscordPanel := Self.CreateLabeledPanel(tab, 'Discord Settings', panelTop, 130, 10, clBlue);
  Self.DiscordPanel.SetLeft(TControl.AdjustToDPI(10));

  with Self.WebhookInfo do
  begin
    Create(Self.DiscordPanel.Panel);
    SetLeft(TControl.AdjustToDPI(150));
    SetTop(TControl.AdjustToDPI(5));
    SetCaption('Click here to learn how to generate your own Discord webhook URL');
    SetHint('Click here to learn how to generate your own Discord webhook URL');
    setOnClick(@OpenURL);
    SetFontSize(TControl.AdjustToDPI(9));
    SetFontColor(clBlue);
  end;

  with Self.WebHookInput do
  begin
    Create(Self.DiscordPanel.Panel);
    SetCaption('Webhook URL');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(TControl.AdjustToDPI(25));
    SetWidth(TControl.AdjustToDPI(350));
    SetText(SavedWebhookURL);
    SetPasswordChar('*');
    SetHint('Your Discord webhook URL.');
  end;

  with Self.TestButton do
  begin
    Create(Self.DiscordPanel.Panel);
    SetCaption('Test Webhook');
    SetLeft(Self.WebHookInput.GetRight + TControl.AdjustToDPI(10));
    SetTop(Self.WebHookInput.GetTop + TControl.AdjustToDPI(15));
    SetWidth(TControl.AdjustToDPI(90));
    SetHeight(TControl.AdjustToDPI(25));
    SetOnClick(@TestButtonClick);
    SetHint('Send a test message to your webhook.');
  end;

  with Self.ScreenshotOnLevelCheckBox do
  begin
    Create(Self.DiscordPanel.Panel);
    SetCaption('Screenshot on Level Up');
    SetLeft(TControl.AdjustToDPI(20));
    SetTop(Self.WebHookInput.GetTop + TControl.AdjustToDPI(50));
    SetHint('Takes a screenshot and sends to Discord when you level up');
    SetChecked(SavedScreenshotOnLevel);
  end;

  with Self.HourlyReportsCheckBox do
  begin
    Create(Self.DiscordPanel.Panel);
    SetCaption('Hourly Progress Reports');
    SetLeft(Self.ScreenshotOnLevelCheckBox.GetRight + TControl.AdjustToDPI(20));
    SetTop(Self.ScreenshotOnLevelCheckBox.GetTop);
    SetHint('Sends detailed progress embeds every hour');
    SetChecked(SavedHourlyReports);
  end;

  with Self.SessionSummaryCheckBox do
  begin
    Create(Self.DiscordPanel.Panel);
    SetCaption('Session Summary on Stop');
    SetLeft(Self.HourlyReportsCheckBox.GetRight + TControl.AdjustToDPI(20));
    SetTop(Self.HourlyReportsCheckBox.GetTop);
    SetHint('Sends a detailed summary embed when script stops');
    SetChecked(SavedSessionSummary);
  end;

  Self.WebhooksCheckboxChanged(nil);
  Self.WorldHoppingCheckboxChanged(nil);

  Self.CreateAntibanManager();
  
  for tab in Self.Tabs do
  begin
    if tab.GetCaption() = 'Antiban Manager' then
    begin
      with Self.LoseFocusCheckBox do
      begin
        Create(tab);
        SetCaption('Lose Focus');
        SetLeft(TControl.AdjustToDPI(90));
        SetTop(TControl.AdjustToDPI(220));
        SetChecked(SavedLoseFocus);
        SetHint('Enable or disable losing client focus during combat.');
      end;
      Break;
    end;
  end;
  
  Self.CreateWaspLibSettings();
  Self.CreateAPISettings();

  inherited;
end;

var
  Config: TConfig;
{$ENDIF}

procedure GemStoneCrabSlayer.SendTerminationNotification();
begin
  try
    if not APIClient.Disabled then
    begin
      Self.SubmitAPIStats();
    end;
  except
    WriteLn('[API] Error submitting final stats: ' + GetExceptionMessage);
  end;
  
  Self.SendSessionSummary();
end;

procedure GemStoneCrabSlayer.CheckHourlyReport();
var
  CurrentTime: Int64;
begin
  CurrentTime := Self.RunningTime.ElapsedTime;
  
  if (CurrentTime - Self.LastHourlyReportTime) >= 3600000 then
  begin
    Self.SendHourlyReport();
    Self.LastHourlyReportTime := CurrentTime;
  end;
end;

procedure GemStoneCrabSlayer.CheckSystemUpdate();
var
  CurrentTime: UInt64;
  SystemUpdateThreshold: Integer;
begin
  CurrentTime := GetTickCount();
  
  if (CurrentTime - Self.LastSystemUpdateCheck) < 30000 then
    Exit;
    
  Self.LastSystemUpdateCheck := CurrentTime;
  
  SystemUpdateThreshold := 15;
  
  if Chat.CheckSystemUpdate(SystemUpdateThreshold) then
  begin
    WriteLn('SYSTEM UPDATE DETECTED! Server going down in ' + IntToStr(SystemUpdateThreshold) + ' minutes or less!');
    
    if not Self.SystemUpdateWarningShown then
    begin
      Self.SystemUpdateWarningShown := True;
      
      if ENABLEWEBHOOKS then
      begin
        try
          Discord.Webhook.Content := '**SYSTEM UPDATE DETECTED** :warning: Server going down in ' + IntToStr(SystemUpdateThreshold) + ' minutes or less! Preparing for safe logout...';
          Discord.Send();
        except
          WriteLn('[Discord] Failed to send system update warning');
        end;
      end;
    end;
    
    // Only logout if we're NOT in combat
    if not (Self.InCombat or Self.IsAttacking) then
    begin
      WriteLn('Not in combat - logging out safely for system update');
      
      if ENABLEWEBHOOKS then
      begin
        try
          Discord.Webhook.Content := '**SAFE LOGOUT** :white_check_mark: Successfully logged out before system update. Runtime: ' + SRL.MsToTime(GetTimeRunning(), Time_Short);
          Discord.SendScreenshot(False);
        except
          WriteLn('[Discord] Failed to send safe logout notification');
        end;
      end;
      
      Logout.ClickLogout();
      TerminateScript('System update - safe logout completed');
    end
    else
    begin
      WriteLn('Currently in combat - CANNOT logout during combat! Waiting for combat to end...');
      WriteLn('WARNING: Server will shutdown soon! Combat must end naturally before logout!');
    end;
  end;
end;

function FormatRoundedNumber(Number: Integer): String;
begin
  if Number >= 1000000 then
    Result := FormatFloat('0.0M', Number / 1000000)
  else if Number >= 1000 then
    Result := FormatFloat('0K', Number / 1000)
  else
    Result := SRL.FormatNumber(Number);
end;

procedure GemStoneCrabSlayer.SendLevelUpNotification(NewLevel: Int32);
var
  EmbedIdx: Int32;
  CurrentXP, TotalXPGained: Int32;
begin
  if not SENDLEVELUPNOTIFICATIONMSG or not ENABLEWEBHOOKS then Exit;
  try
    CurrentXP := Self.SafeReadXPBar();
    WriteLn('XPBar Read returns: ' + IntToStr(CurrentXP));
    TotalXPGained := CurrentXP - Self.StartXP;
    
    Discord.Webhook.Content := '**LEVEL UP!** :tada:';
    
    EmbedIdx := Discord.Webhook.AddEmbed();
    Discord.Webhook.Embeds[EmbedIdx].Title := 'Combat Level Up!';
    Discord.Webhook.Embeds[EmbedIdx].Color := $00FF00;
    Discord.Webhook.Embeds[EmbedIdx].Description := 'New Level: ' + IntToStr(NewLevel) + LineEnding +
                                                    'XP Gained: ' + FormatRoundedNumber(TotalXPGained) + LineEnding +
                                                    'Runtime: ' + SRL.MsToTime(GetTimeRunning, Time_Short);
    
    if Discord.SendScreenshot(False) then
      WriteLn('[Discord] Level up notification sent!')
    else
      WriteLn('[Discord] Failed to send level up notification: ' + Discord.LastError);
  except
    WriteLn('[Discord] Error sending level up notification: ' + GetExceptionMessage);
  end;
end;

procedure GemStoneCrabSlayer.SendHourlyReport();
var
  EmbedIdx: Int32;
  CurrentXP, TotalXPGained: Int32;
  XPPerHour: Int32;
begin
  if not SENDHOURLYREPORTMSG or not ENABLEWEBHOOKS then Exit;
  
  CurrentXP := Self.SafeReadXPBar();
  TotalXPGained := CurrentXP - Self.StartXP;
  
  XPPerHour := Round(TotalXPGained / (ActiveTimer.ElapsedTime / 3600000));
  
  try
    Discord.Webhook.Content := '**Hourly Progress Report** :chart_with_upwards_trend:';
    
    EmbedIdx := Discord.Webhook.AddEmbed();
    Discord.Webhook.Embeds[EmbedIdx].Title := 'BigAussies Gemstone Crab Slayer - Hourly Report';
    Discord.Webhook.Embeds[EmbedIdx].Color := $FFA500;
    Discord.Webhook.Embeds[EmbedIdx].Description := 'Runtime: ' + SRL.MsToTime(GetTimeRunning, Time_Short) + LineEnding +
                                                    'XP Gained: ' + FormatRoundedNumber(TotalXPGained) + LineEnding +
                                                    'XP/Hour: ' + FormatRoundedNumber(XPPerHour);
    
    if Discord.Send() then
      WriteLn('[Discord] Hourly report sent!')
    else
      WriteLn('[Discord] Failed to send hourly report: ' + Discord.LastError);
  except
    WriteLn('[Discord] Error sending hourly report: ' + GetExceptionMessage);
  end;
end;

procedure GemStoneCrabSlayer.SendSessionSummary();
var
  EmbedIdx: Int32;
  CurrentXP, TotalXPGained: Int32;
  XPPerHour: Int32;
begin
  if not SENDSESSIONSUMMARYMSG or not ENABLEWEBHOOKS then Exit;
  
  CurrentXP := Self.SafeReadXPBar();
  TotalXPGained := CurrentXP - Self.StartXP;
  
  XPPerHour := Round(TotalXPGained / (ActiveTimer.ElapsedTime / 3600000));
  
  try
    Discord.Webhook.Content := '**Session Complete!** :checkered_flag:';
    
    EmbedIdx := Discord.Webhook.AddEmbed();
    Discord.Webhook.Embeds[EmbedIdx].Title := 'BigAussies Gemstone Crab Slayer - Session Summary';
    Discord.Webhook.Embeds[EmbedIdx].Color := $0000FF;
    Discord.Webhook.Embeds[EmbedIdx].Description := 'Total Runtime: ' + SRL.MsToTime(GetTimeRunning, Time_Short) + LineEnding +
                                                    'Total XP Gained: ' + FormatRoundedNumber(TotalXPGained) + LineEnding +
                                                    'Average XP/Hour: ' + FormatRoundedNumber(XPPerHour);
    
    if Discord.SendScreenshot(False) then
      WriteLn('[Discord] Session summary sent!')
    else
      WriteLn('[Discord] Failed to send session summary: ' + Discord.LastError);
  except
    WriteLn('[Discord] Error sending session summary: ' + GetExceptionMessage);
  end;
end;

procedure GemStoneCrabSlayer.SubmitAPIStats();
var
  CurrentXP, TotalXPGained: Int32;
  CurrentTime: UInt64;
begin
  if not APIClient.Disabled then
    Exit;
    
  CurrentTime := GetTickCount();
  
  if (CurrentTime - Self.LastAPIUpdate) < Self.ApiUpdateInterval then
    Exit;
    
  CurrentXP := Self.SafeReadXPBar();
  TotalXPGained := CurrentXP - Self.StartXP;
  
  try
    APIClient.UpdatePayload(TotalXPGained, 0, Round((CurrentTime - Self.LastAPIUpdate) / 1000));
    
    if APIClient.SubmitStats(APIClient.GetUUID()) then
    begin
      Self.LastAPIUpdate := CurrentTime;
    end
    else
      WriteLn('[API] Failed to submit stats');
  except
    WriteLn('[API] Error submitting stats: ' + GetExceptionMessage);
  end;
end;

procedure GemStoneCrabSlayer.TakeScreenshot(Name: String);
var
  i: Int32;
begin
  CreateDirectory('Screenshots/');
  i := Length(GetFiles('Screenshots/', 'png'));
  SaveScreenshot('Screenshots/GemStoneCrab' + Name + '_' + IntToStr(i) + '.png');
end;

function GemStoneCrabSlayer.FindAndClickCaveEntrance(): Boolean;
var
  RedExclamationDots: TPointArray;
  i, Attempts: Int32;
  MinimapPoint: TPoint;
  MainscreenPoint: TPoint;
  MouseOverAttempts: Int32;
  RotationAttempts: Int32;
  StartTime: UInt64;
  MaxWaitTime: UInt64;
  CaveBlocked: Boolean;
  EnteredCave: Boolean;
begin
  Result := False;
  
  if (GetTickCount() - Self.LastCaveAttemptTime) > 60000 then
  begin
    Self.CaveEntranceAttempts := 0;
    Self.FailsafeActive := False;
  end;
  
  if Self.CaveEntranceAttempts >= 3 then
  begin
    WriteLn('FAILSAFE: Already tried cave entrance 3 times, assuming Mr Crabs is here!');
    Self.FailsafeActive := True;
    
    if Self.FindGemStoneCrab() then
    begin
      WriteLn('FAILSAFE: Found Mr Crabs! Resetting cave attempts.');
      Self.CaveEntranceAttempts := 0;
      Self.FailsafeActive := False;
      Exit(True);
    end
    else
    begin
      WriteLn('FAILSAFE: Could not find Mr Crabs after 3 cave attempts. Terminating script.');
      Self.TakeScreenshot('_FailsafeTermination');
      TerminateScript('Failsafe activated: Could not find cave entrance or Mr Crabs after multiple attempts');
    end;
  end;
  
  for Attempts := 1 to 3 do
  begin
    WriteLn('Looking for cave entrance... Attempt ', Attempts, ' (Total: ', Self.CaveEntranceAttempts + 1, ')');
    
    if SRL.FindColors(RedExclamationDots, CTS2(8422138, 7, 0.05, 0.76), Minimap.Bounds) then
    begin
      for i := 0 to High(RedExclamationDots) do
      begin
        MinimapPoint := RedExclamationDots[i];
        MainscreenPoint := Minimap.PointToMS(MinimapPoint);
        
        if not MainScreen.Bounds.Contains(MainscreenPoint) then
          Continue;
        
        MouseOverAttempts := 0;
        RotationAttempts := 0;
        repeat
          Inc(MouseOverAttempts);
          Mouse.Move(MainscreenPoint);
          
          if MainScreen.IsUpText(['Cave']) then
          begin
            WriteLn('Found cave entrance, clicking...');
            Mouse.Click(MOUSE_LEFT);
            
            if MainScreen.DidRedClick() then
            begin
              WriteLn('Successfully clicked cave.');
              
              StartTime := GetTickCount();
              MaxWaitTime := 15000;
              CaveBlocked := False;
              EnteredCave := False;
              
              repeat
                Wait(200, 400);
                
                if Chat.HasContinue() then
                begin
                  CaveBlocked := True;
                  Break;
                end;
                
                // Check if we started entering the cave (minimap blck
                if Minimap.PercentBlack() > 80 then
                begin
                  EnteredCave := True;
                  Break;
                end;
                
              until (GetTickCount() - StartTime) > MaxWaitTime;
              
              if CaveBlocked then
              begin
                WriteLn('Cave is blocked! Boss must still be here - returning to boss search');
                Chat.ClickContinue();
                Wait(500, 1000);
                Result := False;
                Exit;
              end
              else if EnteredCave then
              begin
                WriteLn('Entered cave');
                
                if WaitUntil(Minimap.PercentBlack() < 20, 100, 10000) then
                begin
                  WriteLn('We are in the cave');
                  Self.CaveEntranceAttempts := 0;
                  Self.FailsafeActive := False;
                  Self.LastCaveEntryTime := GetTickCount();
                  Result := True;
                  Exit;
                end
                else
                begin
                  WriteLn('Cave entry timed out');
                end;
              end
              else
              begin
                WriteLn('Timed out waiting for cave response');
              end;
            end;
            Break;
          end
          else if MouseOverAttempts >= 2 then
          begin
            Inc(RotationAttempts);
            if RotationAttempts >= 3 then
            begin
              WriteLn('Too many rotations for this cave dot, trying next');
              Break;
            end;
            
            WriteLn('Failed to get cave uptext, rotating camera...');
            Antiban.RandomRotate();
            Wait(500, 1000);
            
            MainscreenPoint := Minimap.PointToMS(MinimapPoint);
            if not MainScreen.Bounds.Contains(MainscreenPoint) then
            begin
              WriteLn('Cave position moved off-screen after rotation');
              Break;
            end;
            
            WriteLn('Recalculated cave position after rotation, moving mouse...');
            Mouse.Move(MainscreenPoint);
            Wait(300, 500);
            
            MouseOverAttempts := 0;
          end;
        until MouseOverAttempts >= 2;
      end;
    end;
    
    if not Result then
    begin
      WriteLn('Cave entrance not found on attempt ', Attempts);
      Wait(1000, 2000);
    end;
  end;
  
  if not Result then
  begin
    Self.CaveEntranceAttempts := Self.CaveEntranceAttempts + 1;
    Self.LastCaveAttemptTime := GetTickCount();
    WriteLn('Failed to find cave entrance. Total attempts: ', Self.CaveEntranceAttempts);
  end;
end;

function GemStoneCrabSlayer.FindGemStoneCrab(): Boolean;
var
  YellowDots, MiningIcons, NearbyDots: TPointArray;
  i, j: Int32;
  MinimapPoint: TPoint;
  MainscreenPoint: TPoint;
  CurrentUpText: String;
  SearchAttempts: Int32;
  StartXP: Integer;
  TimeoutStart: UInt64;
begin
  Result := False;
  WriteLn('Looking for Mr Crabs...');
  
  StartXP := Self.SafeReadXPBar();
  SearchAttempts := 0;
  
  while (SearchAttempts < 3) and not Result do
  begin
    Inc(SearchAttempts);
    WriteLn('Boss search attempt ', SearchAttempts, '/3');
    
    // Find mining icons
    SRL.FindColors(MiningIcons, CTS2(2181491, 13, 0.08, 1.33), Minimap.Bounds);
    
    if Length(MiningIcons) = 0 then 
    begin
      WriteLn('No mining icon found');
      Exit(False);
    end;
    
    WriteLn('Found ', Length(MiningIcons), ' mining icon(s)');
    
    // Find all yellow NPC dots
    YellowDots := FindYellowNPCDots();
    
    if Length(YellowDots) = 0 then
    begin
      WriteLn('No NPCs detected');
      Exit(False);
    end;
    
    WriteLn('Found ', Length(YellowDots), ' NPC dot(s)');
    
    // Filter to only dots near mining icons
    NearbyDots := [];
    for i := 0 to High(YellowDots) do
    begin
      for j := 0 to High(MiningIcons) do
      begin
        if YellowDots[i].DistanceTo(MiningIcons[j]) <= 15 then
        begin
          NearbyDots := NearbyDots + [YellowDots[i]];
          Break;
        end;
      end;
    end;
    
    WriteLn('Found ', Length(NearbyDots), ' NPC dot(s) near mining icons');
    
    if Length(NearbyDots) = 0 then
    begin
      WriteLn('No NPCs found near mining icon going to cave');
      Exit(False);
    end
    else
    begin
      for i := 0 to High(NearbyDots) do
      begin
        MinimapPoint := NearbyDots[i];
        MainscreenPoint := Minimap.PointToMS(MinimapPoint);
        
        if not MainScreen.Bounds.Contains(MainscreenPoint) then
        begin
          Continue;
        end;

        Mouse.Move(MainscreenPoint);
        
        CurrentUpText := MainScreen.GetUpText();
        WriteLn('Current uptext: "', CurrentUpText, '"');
        
        if MainScreen.IsUpText(['(level-160)']) then
        begin
          WriteLn('Found Gemstone Crab! Clicking to attack...');
          Mouse.Click(MOUSE_LEFT);
          
          if MainScreen.DidRedClick() then
          begin
            WriteLn('Red click successful, waiting for XP...');
            TimeoutStart := GetTickCount();
            
            repeat
              Wait(500, 1000);
              
              if Self.SafeReadXPBar() > StartXP then
              begin
                Self.IsAttacking := True;
                Self.InCombat := True;
                Self.PrevXP := Self.SafeReadXPBar();
                Self.LastHealthCheck := GetTickCount();
                WL.Activity.Restart();
                
                Self.ConsecutiveFailedAttacks := 0;
                WriteLn('Successfully attacked boss and gained XP!');
                
                Result := True;
                Exit;
              end;
              
            until (GetTickCount() - TimeoutStart) > 5000;
            
            WriteLn('No XP gained within 5 seconds after clicking');
            
            Inc(Self.ConsecutiveFailedAttacks);
            Self.LastFailedAttackTime := GetTickCount();
            WriteLn('Boss clicked but no XP gained. Consecutive failed attacks: ', Self.ConsecutiveFailedAttacks, '/3');
            
            if Self.ConsecutiveFailedAttacks >= 3 then
            begin
              WriteLn('3 consecutive boss clicks failed to gain XP!');
              WriteLn('This likely means we are out of ammo/runes. Logging out and terminating script.');
              
              Self.TakeScreenshot('_NoAmmoFailsafe');
              
              if ENABLEWEBHOOKS then
              begin
                try
                  Discord.Webhook.Content := 'Failed to gain XP! Script will logout and terminate. Please check your ammo/runes!';
                  Discord.SendScreenshot(False);
                except
                  WriteLn('[Discord] Failed to send no ammo notification');
                end;
              end;
              
              Logout.ClickLogout();
              TerminateScript('No XP gained from 3 consecutive attacks');
            end;
            
            Result := True;
            Exit;
          end
          else
          begin
            WriteLn('Red click failed - click was not successful');
          end;
        end;
      end;
    end;
    
    if not Result and (SearchAttempts < 3) then
    begin
      Antiban.RandomRotate();
      Wait(1000, 1500);
    end;
  end;

  if not Result then
  begin
    WriteLn('Mr Crabs not found after ', SearchAttempts, ' search attempts');
  end;
end;

function GemStoneCrabSlayer.IsInCombat(): Boolean;
var
  CurrentXP: Integer;
begin
  CurrentXP := Self.SafeReadXPBar();
  
  if CurrentXP > Self.PrevXP then
  begin
    Self.PrevXP := CurrentXP;
    Self.LastHealthCheck := GetTickCount();
    Self.InCombat := True;
    WL.Activity.Restart();
    Result := True;
  end
  else
  begin
    if Self.InCombat and ((GetTickCount() - Self.LastHealthCheck) < 15000) then
      Result := True
    else
    begin
      Self.InCombat := False;
      Self.IsAttacking := False;
      Result := False;
    end;
  end;
end;

function GemStoneCrabSlayer.HandleCombat(): Boolean;
var
  CurrentXP: Integer;
  TimeSinceLastXP: UInt64;
begin
  Result := True;
  
  CurrentXP := Self.SafeReadXPBar();
  TimeSinceLastXP := GetTickCount() - Self.LastHealthCheck;
  
  if CurrentXP > Self.PrevXP then
  begin
    Self.PrevXP := CurrentXP;
    Self.LastHealthCheck := GetTickCount();
    Self.InCombat := True;
    WL.Activity.Restart();

    if ABLOSEFOCUS then
    begin
      Antiban.LoseFocus();
    end;
  end
  else
  begin
    if Length(MainScreen.FindHPBars()) = 0 then
    begin
      WriteLn('Combat ended - no bars found');
      Self.InCombat := False;
      Self.IsAttacking := False;
      Self.TotalKills := Self.TotalKills + 1;
      Result := False;
    end
    else if TimeSinceLastXP > 15000 then
    begin
      WriteLn('Combat ended - no XP gained for 15 seconds');
      Self.InCombat := False;
      Self.IsAttacking := False;
      Self.TotalKills := Self.TotalKills + 1;
      Result := False;
    end;
  end;
end;

procedure GemStoneCrabSlayer.CheckForLevelUp();
begin
  Self.CurrentLevel := Stats.GetLevel(ERSSkill.ATTACK);
  if Self.CurrentLevel > Self.LastLevel then
  begin
    Self.LastLevel := Self.CurrentLevel;
    Self.SendLevelUpNotification(Self.CurrentLevel);
  end;
end;

procedure GemStoneCrabSlayer.DoAction();
var
  CurrentXP: Integer;
  TimeSinceLastXP: UInt64;
begin
  if (Self.ConsecutiveFailedAttacks > 0) and 
     (Self.LastFailedAttackTime > 0) and 
     ((GetTickCount() - Self.LastFailedAttackTime) > 600000) then
  begin
    Self.ConsecutiveFailedAttacks := 0;
    Self.LastFailedAttackTime := 0;
  end;
  
  CurrentXP := Self.SafeReadXPBar();
  if CurrentXP > Self.PrevXP then
  begin
    Self.PrevXP := CurrentXP;
    Self.LastHealthCheck := GetTickCount();
    Self.InCombat := True;
    WL.Activity.Restart();
  end;
  
  TimeSinceLastXP := GetTickCount() - Self.LastHealthCheck;
  if TimeSinceLastXP > 15000 then
  begin
    if Self.InCombat or Self.IsAttacking then
    begin
      WriteLn('No XP for 15+ seconds - combat ended');
      Self.InCombat := False;
      Self.IsAttacking := False;
    end;
  end;
  
  if Self.IsAttacking and (TimeSinceLastXP > 8000) then
  begin
    Self.IsAttacking := False;
  end;

  if Self.IsInCombat() then
  begin
    if not Self.HandleCombat() then
    begin
      WriteLn('Combat ended, resetting combat state');
      Self.InCombat := False;
      Self.IsAttacking := False;
    end;
  end
  else
  begin
    if (Self.LastCaveEntryTime > 0) and ((GetTickCount() - Self.LastCaveEntryTime) < 15000) then
    begin
      WriteLn('Waiting for boss to spawn after cave entry... (' + 
              IntToStr(Round((GetTickCount() - Self.LastCaveEntryTime) / 1000)) + 's)');
      
      if Self.FindGemStoneCrab() then
      begin
        WriteLn('Boss spawned! Found and attacked Gemstone Crab!');
        Self.LastCaveEntryTime := 0;
      end
      else
      begin
        Wait(1000, 1500);
      end;
    end
    else
    begin
      if Self.FindGemStoneCrab() then
      begin
        WriteLn('Found and attacked Gemstone Crab!');
      end
      else
      begin
        WriteLn('No boss found - attempting to enter cave');
        if Self.FindAndClickCaveEntrance() then
        begin
          WriteLn('Cave entry successful - boss should spawn soon');
          Self.LastCaveEntryTime := GetTickCount();
        end
        else
        begin
          WriteLn('Cave blocked - boss must still be here, searching again');
        end;
      end;
    end;
  end;
end;

procedure GemStoneCrabSlayer.Report();
var
  CurrentXP: Integer;
  Runtime: Integer;
  XPPerHour, XPPerHourExcludingBreaks: Integer;
  CurrentTime: UInt64;
begin
  CurrentTime := GetTickCount();
  
  if (CurrentTime - Self.LastReportTime) < 3000 then
    Exit;
    
  Self.LastReportTime := CurrentTime;
  
  //ClearDebug();
  
  CurrentXP := Self.SafeReadXPBar();
  Self.GainedXP := CurrentXP - Self.StartXP;
  Runtime := GetTimeRunning();
    
  XPPerHour := Round((Self.GainedXP) / (Self.RunningTime.ElapsedTime / 3600000));
  XPPerHourExcludingBreaks := Round((Self.GainedXP) / (ActiveTimer.ElapsedTime / 3600000));
  
  Self.SubmitAPIStats();
    
  WriteLn('========================================');
  WriteLn('    BigAussies Gemstone Crab Slayer   ');
  WriteLn('========================================');
  WriteLn('   Runtime: ' + SRL.MsToTime(Runtime, Time_Short));
  WriteLn('   XP Gained: ' + FormatRoundedNumber(Self.GainedXP));
  WriteLn('   XP/Hour: ' + FormatRoundedNumber(XPPerHourExcludingBreaks));

  if Length(Antiban.Breaks) > 0 then
    WriteLn('   Next break: ' + SRL.MsToTime(Max(0, Round(Antiban.Breaks[0].NextAtTime - Self.RunningTime.ElapsedTime)), Time_Short));
  if Length(Antiban.Sleeps) > 0 then
    if Antiban.Sleeps[0].NextAtTime > GetTimeRunning then
      WriteLn('   Next sleep: ' + SRL.MsToTime(Max(0, Round(Antiban.Sleeps[0].NextAtTime - Self.RunningTime.ElapsedTime)), Time_Short));
  
  if ENABLEWORLDHOPPING then
  begin
    WriteLn('   Hops Completed: ' + IntToStr(Self.WorldHopsCompleted));
    if Self.NextWorldHopTime > GetTickCount() then
      WriteLn('   Next Hop: ' + SRL.MsToTime(Self.NextWorldHopTime - GetTickCount(), Time_Short))
    else
      WriteLn('   Next Hop: READY!');
  end
  else
    WriteLn('   World Hopping: DISABLED');
    
  if Self.SystemUpdateWarningShown then
    WriteLn('   WARNING: System update detected! Will logout when combat ends.');
    
  WriteLn('========================================');
  WriteLn('    BigAussies Gemstone Crab Slayer   ');
  WriteLn('           Version: ' + {$MACRO SCRIPT_REVISION});
  WriteLn('========================================');
end;

procedure GemStoneCrabSlayer.Init(MaxActions: UInt32; MaxTime: UInt64); override;
begin
  inherited;
  
  SetupNPCDTMs();
  Options.SetZoomLevel(RandomRange(5, 15));
  
   if ENABLEWEBHOOKS then
     Discord.Setup(WEBHOOKURL); 
  
  if SENDSESSIONSUMMARYMSG and ENABLEWEBHOOKS then
    AddOnTerminate(@Self.SendTerminationNotification);
  
  Self.StartXP := Self.SafeReadXPBar();
  Self.PrevXP := Self.StartXP;
  Self.TotalKills := 0;
  Self.LastLevel := Stats.GetLevel(ERSSkill.ATTACK);
  Self.LastHourlyReportTime := 0;
  
  Self.InCombat := False;
  Self.IsAttacking := False;
  Self.LastHealthCheck := GetTickCount();
  
  Self.CaveEntranceAttempts := 0;
  Self.LastCaveAttemptTime := 0;
  Self.LastCaveEntryTime := 0;
  Self.FailsafeActive := False;
  
  Self.ConsecutiveFailedAttacks := 0;
  Self.LastFailedAttackTime := 0;
  Self.LastSuccessfulClick := False;
  
  Self.LastAPIUpdate := GetTickCount();
  Self.ApiUpdateInterval := 5 * 60000;
  
  APIClient.Setup();
  
  Self.RunningTime.Start();
  ActiveTimer.Start();
  
  Self.WorldHopsCompleted := 0;
  Self.LastWorldHopTime := 0;
  Self.SetupWorldHopping();
  Self.LastReportTime := 0;
  Self.LastImageClear := 0;
  Self.LastSystemUpdateCheck := 0;
  Self.SystemUpdateWarningShown := False;
end;

function GemStoneCrabSlayer.SafeReadXPBar(): Integer;
var
  XPValue: Integer;
  AttemptCount: Int32;
  ValidReading: Boolean;
  PreviousValidXP: Integer;
  XPDifference: Integer;
  TimeSinceLastRead: UInt64;
  MaxPossibleGain: Integer;
begin
  Result := Self.PrevXP;
  ValidReading := False;
  AttemptCount := 0;
  
  if Self.PrevXP > 0 then
    PreviousValidXP := Self.PrevXP
  else
    PreviousValidXP := Self.StartXP;
  
  while (not ValidReading) and (AttemptCount < 3) do
  begin
    Inc(AttemptCount);
    XPValue := XPBar.Read();
    
    if XPValue <= 0 then
    begin
      WriteLn('Invalid XP reading: ', XPValue, ' (zero or negative)');
    end
    else if XPValue < 10000 then
    begin
      WriteLn('Invalid XP reading: ', XPValue, ' (too low)');
    end
    else if (PreviousValidXP > 0) then
    begin
      XPDifference := XPValue - PreviousValidXP;
      TimeSinceLastRead := GetTickCount() - Self.LastHealthCheck;
      
      MaxPossibleGain := Round((TimeSinceLastRead / 1000.0) * 100);
      if MaxPossibleGain < 1000 then MaxPossibleGain := 1000;
      
      if XPDifference > MaxPossibleGain then
      begin
        WriteLn('Invalid XP reading: ', XPValue, ' (impossible gain of ', XPDifference, ' XP in ', Round(TimeSinceLastRead/1000), 's)');
      end
      else if XPDifference < -1000 then
      begin
        WriteLn('Invalid XP reading: ', XPValue, ' (impossible loss of ', Abs(XPDifference), ' XP)');
      end
      else
      begin
        ValidReading := True;
        Result := XPValue;
      end;
    end
    else
    begin
      ValidReading := True;
      Result := XPValue;
    end;
    
    if not ValidReading then
    begin
      if AttemptCount < 3 then
      begin
        WriteLn('Rotating camera for xp bar.');
        Antiban.RandomRotate();
        Wait(1000, 1500);
      end;
    end;
  end;
  
  if not ValidReading then
  begin
    WriteLn('Failed to get valid XP reading after 3 attempts: ', PreviousValidXP);
    Result := PreviousValidXP;
  end;
end;

procedure GemStoneCrabSlayer.Run(MaxActions: UInt32; MaxTime: UInt64);
var
  LastExceptionTime: UInt64;
  ExceptionCount: Integer;
begin
  try
    Self.Init(MaxActions, MaxTime);
    repeat
      try
        if (GetTickCount() - Self.LastImageClear) >= 30000 then
        begin
          RSClient.Image.Clear;
          Self.LastImageClear := GetTickCount();
        end;
        
        Self.CheckForLevelUp();
        Self.CheckHourlyReport();
        Self.CheckSystemUpdate();
        
        if Self.ShouldHopWorld() then
        begin
          Self.DoWorldHop();
          Continue;
        end;
        
        Self.DoAction();
        if Self.InCombat or Self.IsAttacking then
        begin
          Self.DoAntiban(False, False); // No breaks or sleeps during combat
        end
        else
        begin
          Self.DoAntiban(True, True); // This way we only check out of combat
        end;
        
        if (GetTimeRunning() mod 10000) < 1000 then
          Self.Report();
          
        Wait(100, 300);
        
        if (GetTickCount() - LastExceptionTime) > 600000 then
          ExceptionCount := 0;
          
      except
        Inc(ExceptionCount);
        LastExceptionTime := GetTickCount();
        
        WriteLn('Exception caught: ' + GetExceptionMessage());
        Self.TakeScreenshot('_Exception');
        
        if ExceptionCount >= 5 then
        begin
          if ENABLEWEBHOOKS then
          begin
            try
              Discord.Webhook.Content := '';
              Discord.Webhook.Content += '**SCRIPT CRASHED** :warning: Too many exceptions (' + IntToStr(ExceptionCount) + '). Last error: ' + GetExceptionMessage();
              Discord.Send();
            except
              WriteLn('[Discord] Failed to send crash notification');
            end;
          end;
          TerminateScript('Too many exceptions - script terminated');
        end;
        
        Wait(1000, 2000);
      end;
      
    if WL.Activity.IsFinished() then
    begin
      WriteLn('No activity detected in 5 minutes! Shutting down.');
      Break;
    end;
      
    until Self.ShouldStop();
    
    Self.Report();
    if ENABLEWEBHOOKS then
    begin
      try
        Discord.Webhook.Content := '';
        Discord.Webhook.Content += '**Script finished normally** :checkered_flag: Runtime: ' + SRL.MsToTime(GetTimeRunning(), Time_Short);
        Discord.Send();
      except
        WriteLn('[Discord] Failed to send completion notification');
      end;
    end;
    
  except
    Self.TakeScreenshot('_FatalCrash');
    if ENABLEWEBHOOKS then
    begin
      try
        Discord.Webhook.Content := '';
        Discord.Webhook.Content += '**FATAL CRASH** :skull: Script terminated unexpectedly: ' + GetExceptionMessage();
        Discord.SendScreenshot(True);
      except
        WriteLn('[Discord] Failed to send notification');
      end;
    end;
    raise;
  end;
end;

begin
  {$IFDEF SCRIPT_GUI}
  Sync(@Config.Run);
  {$ENDIF}
  
  try
    GemStoneCrabBot.Run(WLSettings.MaxActions, WLSettings.MaxTime);
  finally
    FreeNPCDTMs();
  end;
end. 